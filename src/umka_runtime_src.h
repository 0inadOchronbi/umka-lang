#ifndef UMKA_RUNTIME_SRC_H_INCLUDED
#define UMKA_RUNTIME_SRC_H_INCLUDED

// This is an automatically generated file. Do not edit it

static const char *runtimeModuleNames[] = {"std.um", "fnc.um", "mat.um", "utf8.um"};

static const char *runtimeModuleSources[] = {

// std.um

"// Umka standard library\n"
"\n"
"// Memory\n"
"\n"
"fn rtlmemcpy(dest, src: ^void, count: int)\n"
"\n"
"fn tobytes*(buf: any): []uint8 {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }\n"
"    bytes := make([]uint8, sizeofself(buf))\n"
"    rtlmemcpy(&bytes[0], buf.__self, sizeofself(buf))\n"
"    return bytes\n"
"}\n"
"\n"
"fn frombytes*(buf: any, bytes: []uint8) {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    if sizeofself(buf) != len(bytes) {\n"
"        error(\"Illegal buffer size\")\n"
"    }\n"
"    rtlmemcpy(buf.__self, &bytes[0], sizeofself(buf))    \n"
"}\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn fopen*    (name: str, mode: str): File {return rtlfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread  (buf: ^void, size, cnt: int, f: File): int\n"
"fn fread*    (f: File, buf: any): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]int8(buf); bytes != null {\n"
"        return rtlfread(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if ubytes := ^[]uint8(buf); ubytes != null {\n"
"        return rtlfread(&ubytes[0], len(ubytes^), 1, f)\n"
"    }        \n"
"    if chars := ^[]char(buf); chars != null {\n"
"        return rtlfread(&chars[0], len(chars^), 1, f)\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types except ^[]int8, ^[]uint8, ^[]char\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite (buf: ^void, size, cnt: int, f: File): int\n"
"fn fwrite*   (f: File, buf: any): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]int8(buf); bytes != null {\n"
"        return rtlfwrite(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if ubytes := ^[]uint8(buf); ubytes != null {\n"
"        return rtlfwrite(&ubytes[0], len(ubytes^), 1, f)\n"
"    } \n"
"    if chars := ^[]char(buf); chars != null {\n"
"        return rtlfwrite(&chars[0], len(chars^), 1, f)\n"
"    }             \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types except ^[]int8, ^[]uint8, ^[]char\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlfseek(f, offset, origin)\n"
"}\n"
"\n"
"fn rtlftell (f: File): int\n"
"fn ftell*   (f: File): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlftell(f)\n"
"}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"fn rtlfeof  (f: File): int\n"
"fn feof*    (f: File): bool {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }                \n"
"    return bool(rtlfeof(f))\n"
"}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Strings\n"
"\n"
"fn ltrim*(s: str): str {\n"
"    start := -1\n"
"    slen := len(s)\n"
"    for i := 0; i < slen; i++ {\n"
"        if s[i] > \' \' {\n"
"            start = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if start == -1 {return \"\"}\n"
"    return slice(s, start)\n"
"}\n"
"\n"
"fn rtrim*(s: str): str {\n"
"    stop := -1\n"
"    slen := len(s)\n"
"    for i := slen - 1; i >= 0; i-- {\n"
"        if s[i] > \' \' {\n"
"            stop = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if stop == -1 {return \"\"}\n"
"    return slice(s, 0, stop + 1)\n"
"}\n"
"\n"
"fn trim*(s: str): str {\n"
"    return ltrim(rtrim(s))\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := sprintf(\"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := sprintf(\"%%.%lldlf\", decimals)\n"
"    s := sprintf(fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Time\n"
"\n"
"type DateTime* = struct {\n"
"    second, minute, hour: int\n"
"    day, month, year: int\n"
"    dayOfWeek, dayOfYear: int\n"
"    isDST: bool\n"
"}\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"fn rtllocaltime(t: int): DateTime\n"
"fn localtime*(t: int): DateTime {return rtllocaltime(t)}\n"
"\n"
"fn rtlgmtime(t: int): DateTime\n"
"fn gmtime*(t: int): DateTime {return rtlgmtime(t)}\n"
"\n"
"fn rtlmktime(d: ^DateTime): int\n"
"fn mktime*(d: DateTime): int {return rtlmktime(&d)}\n"
"\n"
"fn timestr*(d: DateTime): str {\n"
"    return sprintf(\"%4d-%02d-%02d %02d:%02d:%02d\", \n"
"                   d.year, d.month, d.day,\n"
"                   d.hour, d.minute, d.second)\n"
"}\n"
"\n"
"// Command line and environment\n"
"\n"
"fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
"fn rtlsystem(command: str): int\n"
"fn system*(command: str): int {return rtlsystem(command)}\n"
" ",

// fnc.um

"// Umka functional programming tools\n"
"\n"
"type Array* = []any\n"
"\n"
"fn (a: ^Array) map_*(f: fn (x, ctx: any): any, ctx: any): Array {\n"
"    res := make(Array, len(a^))\n"
"    for i := 0; i < len(a^); i++ {\n"
"        res[i] = f(a[i], ctx)\n"
"    }\n"
"    return res\n"
"}\n"
"\n"
"fn (a: ^Array) filter*(f: fn (x, ctx: any): bool, ctx: any): Array {\n"
"    res := make(Array, 0)\n"
"    for i := 0; i < len(a^); i++ {\n"
"        if f(a[i], ctx) {\n"
"            res = append(res, a[i])\n"
"        }\n"
"    }\n"
"    return res\n"
"}\n"
"\n"
"fn (a: ^Array) reduce*(f: fn (x, y, ctx: any): any, ctx: any): any {\n"
"    res := a[0]\n"
"    for i := 1; i < len(a^); i++ {\n"
"        res = f(res, a[i], ctx)\n"
"    }\n"
"    return res\n"
"}\n"
" ",

// mat.um

"// Umka 3D vector/matrix library\n"
"\n"
"type (\n"
"    Vec* = [3]real\n"
"    Mat* = [3]Vec\n"
")\n"
"\n"
"\n"
"// Vector operations\n"
"\n"
"fn (u: ^Vec) add*(v: Vec): Vec         {return Vec{u[0] + v[0], u[1] + v[1], u[2] + v[2]}}\n"
"fn (u: ^Vec) sub*(v: Vec): Vec         {return Vec{u[0] - v[0], u[1] - v[1], u[2] - v[2]}}\n"
"fn (u: ^Vec) mul*(a: real): Vec        {return Vec{u[0] * a, u[1] * a, u[2] * a}}\n"
"fn (u: ^Vec) div*(a: real): Vec        {return Vec{u[0] / a, u[1] / a, u[2] / a}}\n"
"fn (u: ^Vec) dot*(v: Vec): real        {return u[0] * v[0] + u[1] * v[1] + u[2] * v[2]}\n"
"fn (u: ^Vec) cross*(v: Vec): Vec       {return Vec{u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0]}}\n"
"fn (u: ^Vec) elementwise*(v: Vec): Vec {return Vec{u[0] * v[0], u[1] * v[1], u[2] * v[2]}}\n"
"fn (v: ^Vec) norm*(): real             {return sqrt(v.dot(v^))}\n"
"fn (v: ^Vec) normalize*(): Vec         {return v.div(v.norm())}\n"
"\n"
"\n"
"// Matrix operations\n"
"\n"
"fn (m: ^Mat) add*(n: Mat): Mat         {return Mat{m[0].add(n[0]), m[1].add(n[1]), m[2].add(n[2])}}\n"
"fn (m: ^Mat) sub*(n: Mat): Mat         {return Mat{m[0].sub(n[0]), m[1].sub(n[1]), m[2].sub(n[2])}}\n"
"fn (m: ^Mat) mul*(a: real): Mat        {return Mat{m[0].mul(a), m[1].mul(a), m[2].mul(a)}}\n"
"fn (m: ^Mat) div*(a: real): Mat        {return Mat{m[0].div(a), m[1].div(a), m[2].div(a)}}\n"
"fn (m: ^Mat) mulv*(v: Vec): Vec        {return Vec{m[0].dot(v), m[1].dot(v), m[2].dot(v)}}\n"
"\n"
"fn (m: ^Mat) mulm*(n: Mat): Mat {\n"
"    var res: Mat\n"
"    for i := 0; i < 3; i++ {\n"
"        for j := 0; j < 3; j++ {\n"
"            for k := 0; k < 3; k++ {\n"
"                res[i][j] += m[i][k] * n[k][j]\n"
"            }\n"
"        }\n"
"    }\n"
"    return res\n"
"}\n"
"\n"
"fn identity*(): Mat {\n"
"    var res: Mat\n"
"    for i := 0; i < 3; i++ {\n"
"        res[i][i] = 1\n"
"    }\n"
"    return res\n"
"}\n"
"\n"
"fn (m: ^Mat) transpose*(): Mat {\n"
"    var res: Mat\n"
"    for i := 0; i < 3; i++ {\n"
"        for j := 0; j < 3; j++ {\n"
"            res[i][j] = m[j][i]\n"
"        }\n"
"    }\n"
"    return res\n"
"}\n"
"\n"
"fn (m: ^Mat) normalize*(): Mat {\n"
"    return m.add(m.mulm(identity().sub(m.transpose().mulm(m^))).mul(0.5))\n"
"}\n"
"\n"
"\n"
"// Rotations\n"
"\n"
"fn (v: ^Vec) toRateMat*(): Mat {\n"
"    return Mat{Vec{ 0,    -v[2],  v[1]},\n"
"               Vec{ v[2],  0,    -v[0]},\n"
"               Vec{-v[1],  v[0],  0   }}\n"
"}\n"
"\n"
"fn (v: ^Vec) toAttMat*(): Mat {\n"
"    // v = {roll, pitch, yaw}\n"
"\n"
"    sr := sin(v[0]);  cr := cos(v[0])\n"
"    sp := sin(v[1]);  cp := cos(v[1])\n"
"    sy := sin(v[2]);  cy := cos(v[2])\n"
"\n"
"    rollMat  := Mat{Vec{ 1,   0,   0 },\n"
"                    Vec{ 0,   cr, -sr},\n"
"                    Vec{ 0,   sr,  cr}}\n"
"\n"
"    pitchMat := Mat{Vec{ cp,  0,   sp},\n"
"                    Vec{ 0,   1,   0 },\n"
"                    Vec{-sp,  0,   cp}}\n"
"\n"
"    yawMat   := Mat{Vec{ cy, -sy,  0 },\n"
"                    Vec{ sy,  cy,  0 },\n"
"                    Vec{ 0,   0,   1 }}\n"
"\n"
"    return yawMat.mulm(pitchMat).mulm(rollMat)\n"
"}\n"
"\n"
"fn (m: ^Mat) toAttAngles*(): Vec {\n"
"    roll  := atan2( m[2][1], m[2][2])\n"
"    pitch := atan2(-m[2][0], sqrt(m[2][1] * m[2][1] + m[2][2] * m[2][2]))\n"
"    yaw   := atan2( m[1][0], m[0][0])\n"
"    return Vec{roll, pitch, yaw}\n"
"} ",

// utf8.um

"// UTF-8 utilities\n"
"\n"
"type Rune* = int32                                \n"
"\n"
"fn (r: ^Rune) size*(): int {\n"
"    if r^ <= 0x7f     {return 1}\n"
"    if r^ <= 0x7ff    {return 2}\n"
"    if r^ <= 0xffff   {return 3}\n"
"    if r^ <= 0x10ffff {return 4}\n"
"    return 0\n"
"}\n"
"\n"
"fn (r: ^Rune) encode*(): str {\n"
"    size := r.size()\n"
"\n"
"    if size == 1 {\n"
"        return str(char(r^))\n"
"    }\n"
"\n"
"    out := make([]char, size + 1)\n"
"\n"
"    // header is size amount of ones at the start\n"
"    header := 0\n"
"    for i := 0; i < size; i++ {\n"
"        header |= 1 << (7 - i)\n"
"    }\n"
"\n"
"    shift := (size - 1) * 6\n"
"    out[0] = char(((r^ >> shift & 0xff) | header) & 0xff)\n"
"\n"
"    for i := 1; i < size; i++ {\n"
"        shift -= 6\n"
"        out[i] = char(r^ >> shift & 0x3f | 0x80)\n"
"    }\n"
"\n"
"    return str(out)\n"
"}\n"
"\n"
"fn encode*(runes: []Rune): str {\n"
"    s := \"\"\n"
"    for _, r in runes {\n"
"        s += r.encode()\n"
"    }\n"
"    return s\n"
"}\n"
"\n"
"fn nextRune(s: str, pos: int): Rune {\n"
"    c := int32(s[pos])\n"
"\n"
"    // exit early if ascii character is detected\n"
"    if c & 0x80 == 0 {\n"
"        return Rune(c)\n"
"    }\n"
"\n"
"    l := len(s)\n"
"\n"
"    // find size of the rune\n"
"    size := 1\n"
"    for pos + size < l && int(s[pos + size]) & 0xc0 == 0x80 { \n"
"        size++\n"
"    }\n"
"\n"
"    // generate mask for the first byte\n"
"    mask := 0\n"
"    for i := 0; i < 8 - size - 1; i++ {\n"
"        mask |= 1 << i\n"
"    }\n"
"\n"
"    sum := 0\n"
"    shift := (size - 1) * 6\n"
"    for i := 0; i < size && pos + i < l; i++ {\n"
"        sum |= ((int32(s[pos + i]) & mask) << shift)\n"
"        if i == 0 {\n"
"            mask = 0x3f // following bytes have 0011 1111 mask\n"
"        }\n"
"        shift -= 6\n"
"    }\n"
"\n"
"    return sum\n"
"}\n"
"\n"
"fn decode*(s: str): []Rune {\n"
"    runes := make([]Rune, len(s))\n"
"    numRunes := 0\n"
"    l := len(s)\n"
"\n"
"    for i := 0; i < l; numRunes++ {\n"
"        runes[numRunes] = nextRune(s, i)\n"
"        i += runes[numRunes].size()\n"
"    }\n"
"\n"
"    return slice(runes, 0, numRunes)\n"
"}\n"
"\n"
"fn runeCount*(s: str): int {\n"
"    numRunes := 0\n"
"    l := len(s)\n"
"\n"
"    for i := 0; i < l; numRunes++ {\n"
"        r := nextRune(s, i)\n"
"        i += r.size()\n"
"    }\n"
"\n"
"    return numRunes\n"
"}\n"
" "
};

#endif // UMKA_RUNTIME_SRC_H_INCLUDED
