// Hash map

import "std.um"


type (
    Any  = interface{}

    Item = struct {
        key, val: Any
    }

    Iter = struct {
        b, i: int
    }

    Map* = struct {
        data: [][]Item
        iter: Iter
    }
)


const (
    defLen = 32
    rehashThreshold = 2
)


fn serialize(key: Any): []uint8 {
    // Treat a string key as a special case
    if s := ^str(key); s != null {
        bytes := make([]uint8, len(s^))
        for i, ch in s^ {
            bytes[i] = uint8(ch)
        }
        return bytes
    }

    return std.tobytes(key)    
}


fn equal(key1, key2: Any): bool {
    if !selftypeeq(key1, key2) {
        return false
    }

    // Treat a string key as a special case
    if s1, s2 := ^str(key1), ^str(key2); s1 != null && s2 != null {
        return s1^ == s2^
    }

    bytes1, bytes2 := serialize(key1), serialize(key2)
    
    if len(bytes1) != len(bytes2) {
        return false
    }

    for i, byte1 in bytes1 {
        if byte1 != bytes2[i] {
            return false
        }
    }

    return true
}


fn hash(key: Any): uint32 {  // djb2 hash
    bytes := serialize(key)
    var hash: uint32 = 5381;
    for byte in bytes {
        hash = (((hash << 5) + hash) + uint32(byte)) & 0xFFFFFFFF;
    }
    return hash;
}


fn (m: ^Map) rehash()


fn (m: ^Map) get*(key: Any): Any {
    if len(m.data) == 0 {return null}

    b := hash(key) % len(m.data)

    for item in m.data[b] {
        if equal(item.key, key) {
            return item.val
        } 
    }

    return null
}


fn (m: ^Map) set*(key, val: Any) {
    if len(m.data) == 0 {
        m.data = make([][]Item, defLen)
    }

    b := hash(key) % len(m.data)

    if size := len(m.data[b]); size == 0 {
        m.data[b] = []Item{Item{key, val}}
    } else {
        if size > rehashThreshold {
            m.rehash()
            b = hash(key) % len(m.data)         
        } 

        for i := 0; i < len(m.data[b]); i++ {
            if equal(m.data[b][i].key, key) {
                m.data[b][i].val = val
                return
            }
        }

        if len(m.data[b]) == 0 {
            m.data[b] = []Item{Item{key, val}}
        } else {
            m.data[b] = append(m.data[b], Item{key, val})
        }
    }
}


fn (m: ^Map) del*(key: Any) {
    b := hash(key) % len(m.data)

    for i, item in m.data[b] {
        if equal(item.key, key) {
            m.data[b] = delete(m.data[b], i)
            return
        } 
    }
}


fn (m: ^Map) first*(): (Any, Any) {
    m.iter.b = 0

    for m.iter.b < len(m.data); m.iter.b++ {
        m.iter.i = 0
        bucket := m.data[m.iter.b]

        for m.iter.i < len(bucket); m.iter.i++ {
            item := bucket[m.iter.i]
            return item.key, item.val
        }
    }

    var empty: Any
    return empty, empty
}


fn (m: ^Map) next*(): (Any, Any) {
    iStart := m.iter.i + 1

    for m.iter.b < len(m.data); m.iter.b++ {
        m.iter.i = iStart
        bucket := m.data[m.iter.b]

        for m.iter.i < len(bucket); m.iter.i++ {
            item := bucket[m.iter.i]
            return item.key, item.val
        }
        iStart = 0
    }
    
    var empty: Any
    return empty, empty
}


fn (m: ^Map) rehash() {
    n := Map{data: make([][]Item, 2 * len(m.data))}

    for bucket in m.data {
        for item in bucket {
            n.set(item.key, item.val)
        }
    }
  
    m^ = n
}


fn (m: ^Map) toStr*(): str {
    out := "{ "

    for bucket in m.data {
        if len(bucket) == 0 {
            continue
        }

        for item in bucket {
            out += std.rtrim(repr(item.key)) + ": " + std.rtrim(repr(item.val)) + ", "
        }
    }

    if len(out) > 2 {
        out = slice(out, 0, len(out) - 2)
    }

    return out + " }"
}
