import (
    "../../import/std.um"
)


type Expr* = struct {
        atom: str
        car, cdr: ^Expr
}


fn (e: ^Expr) toStr*(): str {
    if e.atom == "" {
        return "(" + e.car.toStr() + " " + e.cdr.toStr() + ")"
    } else {  
        return e.atom
    }
}


fn (e: ^Expr) toBool*(): bool {
    if e.atom != "t" && e.atom != "nil" {
        error("Expression is non-Boolean")
    }
    return e.atom == "t"
}


fn strExpr*(s: str): ^Expr {
    e := new(Expr)
    e.atom = s
    return e
}


fn boolExpr*(b: bool): ^Expr {
    e := new(Expr)
    if b {e.atom = "t"} else {e.atom = "nil"}
    return e
}


fn nilExpr*(): ^Expr {
    e := new(Expr)
    e.atom = "nil"
    return e
}


// Elementary functions

fn car*(x: ^Expr): ^Expr {
    printf("car\n")
    if x.atom == "nil" {
        return x
    }
    if x.atom != "" {
        error("car() is undefined for atom " + x.atom)
    }
    return x.car
}


fn cdr*(x: ^Expr): ^Expr {
    printf("cdr\n")
    if x.atom == "nil" {
        return x
    }    
    if x.atom != "" {
        error("cdr() is undefined for atom " + x.atom)
    }
    return x.cdr
}


fn cons*(x, y: ^Expr): ^Expr {
    printf("cons\n")
    z := new(Expr)
    z.atom = ""
    z.car = x
    z.cdr = y
    return z
}


fn atom*(x: ^Expr): bool {
    printf("atom\n")
    return x.atom != "" || (x.car.atom == "nil" && x.cdr.atom == "nil")
}


fn eq*(x, y: ^Expr): bool {
    printf("eq\n")
    if x.atom == "" || y.atom == "" {
        error("eq() is undefined for non-atom " + x.atom + " or " + y.atom)
    }
    return x.atom == y.atom
}


// Helper functions

fn eval(e, a: ^Expr): ^Expr


fn _null(x: ^Expr): bool {
    printf("null\n")
    return x.atom == "nil" || x.atom == "" && x.car.atom == "nil" && x.cdr.atom == "nil"
}


fn equal(x, y: ^Expr): bool {
    printf("equal\n")
    if atom(x) {
        if atom(y) {
            return eq(x, y)
        } else {
            return false
        }
    } else if equal(car(x), car(y)) {
        return equal(cdr(x), cdr(y))
    } else {
        return false
    }
}


fn pairlis(x, y, a: ^Expr): ^Expr {
    printf("pairlis\n")
    if _null(x) {
        return a
    } else {
        return cons(cons(car(x), car(y)), pairlis(cdr(x), cdr(y), a))
    }
}


fn assoc(x, a: ^Expr): ^Expr {
    printf("assoc\n")
    if equal(car(car(a)), x) {
        return car(a)
    } else {
        return assoc(x, cdr(a))
    }
}


fn evcon(c, a: ^Expr): ^Expr {
    printf("evcon\n")
    if eval(car(car(c)), a).toBool() {
        return eval(car(cdr(car(c))), a)
    } else {
        return evcon(cdr(c), a)
    }    
}


fn evlis(m, a: ^Expr): ^Expr {
    printf("evlis\n")
    if _null(m) {
        return strExpr("nil")
    } else {
        return cons(eval(car(m), a), evlis(cdr(m), a))
    }
}


// Universal function (Lisp 1.5 manual, p. 13)

fn apply(f, x, a: ^Expr): ^Expr {
    printf("apply\n")
    if atom(f) {
        if eq(f, strExpr("car")) {
            return car(car(x))
        } else if eq(f, strExpr("cdr")) {
            return cdr(car(x))
        } else if eq(f, strExpr("cons")) {
            return cons(car(x), car(cdr(x)))
        } else if eq(f, strExpr("atom")) {
            return boolExpr(atom(car(x)))
        } else if eq(f, strExpr("eq")) {
            return boolExpr(eq(car(x), car(cdr(x))))
        } else {
            return apply(eval(f, a), x, a)
        }
    } else if eq(car(f), strExpr("lambda")) {
        return eval(car(cdr(cdr(f))), pairlis(car(cdr(f)), x, a))     
    } else if eq(car(f), strExpr("label")) {
        return apply(car(cdr(cdr(f))), x, cons(cons(car(cdr(f)), car(cdr(cdr(f)))), a))
    } else {
        error("Illegal apply()")
    }    
}


fn eval(e, a: ^Expr): ^Expr {
    printf("eval\n")
    if atom(e) {
        return cdr(assoc(e, a))
    } else if atom(car(e)) {
        if eq(car(e), strExpr("quote")) {
            return car(cdr(e))
        } else if eq(car(e), strExpr("cond")) {
            return evcon(cdr(e), a)
        } else {
            return apply(car(e), evlis(cdr(e), a), a)
        }
    } else {
        return apply(car(e), evlis(cdr(e), a), a)
    }
}


fn evalquote*(f, x: ^Expr): ^Expr {
    printf("evalquote\n")
    return apply(f, x, ev.strExpr("nil"))
}