import "../../import/std.um"


type Expr* = struct {
        atom: str
        car, cdr: ^Expr
}


fn (e: ^Expr) toStr*(): str {
    if e == null {
        return "nil"
    } else if e.atom == "" {
        return "(" + e.car.toStr() + " . " + e.cdr.toStr() + ")"
    } else {  
        return e.atom
    }
}


fn (e: ^Expr) toBool*(): bool {
    return e != null
}


fn strExpr*(s: str): ^Expr {
    e := new(Expr)
    e.atom = s
    return e
}


fn boolExpr*(b: bool): ^Expr {
    e := new(Expr)
    if b {
        return strExpr("t")
    } else {
        return null
    }
}


// Elementary functions

fn car*(x: ^Expr): ^Expr {
    if x == null {
        return null
    } else if x.atom != "" {
        error("car() is undefined for atom " + x.atom)
    } else {
        return x.car
    }
}


fn cdr*(x: ^Expr): ^Expr {
    if x == null {
        return null
    } else if x.atom != "" {
        error("cdr() is undefined for atom " + x.atom)
    } else {
        return x.cdr
    }
}


fn cons*(x, y: ^Expr): ^Expr {
    z := new(Expr)
    z^ = Expr{"", x, y} 
    return z
}


fn atom*(x: ^Expr): bool {
    return x == null || x.atom != ""
}


fn eq*(x, y: ^Expr): bool {
    if x == null {return y == null}
    if y == null {return x == null}
    
    if !atom(x) || !atom(y) {
        error("eq() is undefined for non-atom(s) (" + x.toStr() + ", " + y.toStr() + ")")
    }
    return x.atom == y.atom
}


// Helper functions

fn eval(e, a: ^Expr): ^Expr


fn _null(x: ^Expr): bool {
    return x == null
}


fn equal(x, y: ^Expr): bool {
    if atom(x) {
        if atom(y) {
            return eq(x, y)
        } else {
            return false
        }
    } else if equal(car(x), car(y)) {
        return equal(cdr(x), cdr(y))
    } else {
        return false
    }
}


fn pairlis(x, y, a: ^Expr): ^Expr {
    if _null(x) {
        return a
    } else {
        return cons(cons(car(x), car(y)), pairlis(cdr(x), cdr(y), a))
    }
}


fn assoc(x, a: ^Expr): ^Expr {
    if equal(car(car(a)), x) {
        return car(a)
    } else {
        return assoc(x, cdr(a))
    }
}


fn evcon(c, a: ^Expr): ^Expr {
    if eval(car(car(c)), a).toBool() {
        return eval(car(cdr(car(c))), a)
    } else {
        return evcon(cdr(c), a)
    }    
}


fn evlis(m, a: ^Expr): ^Expr {
    if _null(m) {
        return null
    } else {
        return cons(eval(car(m), a), evlis(cdr(m), a))
    }
}


// Universal function (Lisp 1.5 manual, p. 13)

fn apply(f, x, a: ^Expr): ^Expr {
    if atom(f) {
        if eq(f, strExpr("car")) {
            return car(car(x))
        } else if eq(f, strExpr("cdr")) {
            return cdr(car(x))
        } else if eq(f, strExpr("cons")) {
            return cons(car(x), car(cdr(x)))
        } else if eq(f, strExpr("atom")) {
            return boolExpr(atom(car(x)))
        } else if eq(f, strExpr("eq")) {
            return boolExpr(eq(car(x), car(cdr(x))))        
        } else {
            return apply(eval(f, a), x, a)
        }
    } else if eq(car(f), strExpr("lambda")) {
        return eval(car(cdr(cdr(f))), pairlis(car(cdr(f)), x, a))     
    } else if eq(car(f), strExpr("label")) {
        return apply(car(cdr(cdr(f))), x, cons(cons(car(cdr(f)), car(cdr(cdr(f)))), a))
    } else {
        error("Illegal function call")
    }    
}


fn eval(e, a: ^Expr): ^Expr {
    if atom(e) {
        return cdr(assoc(e, a))
    } else if atom(car(e)) {
        if eq(car(e), strExpr("quote")) {
            return car(cdr(e))
        } else if eq(car(e), strExpr("cond")) {
            return evcon(cdr(e), a)
        } else {
            return apply(car(e), evlis(cdr(e), a), a)
        }
    } else {
        return apply(car(e), evlis(cdr(e), a), a)
    }
}


fn evalquote*(f, x: ^Expr): ^Expr {
    return apply(f, x, null)
}