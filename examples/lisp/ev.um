import (
    "../../import/std.um"
)


type (
    Atom = struct {
        name: str
        val: int
    }
    
    Expr = struct {
        atom: ^Atom
        car, cdr: ^Expr
    }
)


fn (e: ^Expr) strVal(): str {
    if e.atom == null {
        error("String value is undefined for lists")
    }
    return e.atom.name
}


fn (e: ^Expr) intVal(): int {
    if e.atom == null {
        error("Integer value is undefined for lists")
    }
    return e.atom.val
}


fn (e: ^Expr) boolVal(): bool {
    if e.atom == null {
        error("Boolean value is undefined for lists")
    }
    return e.atom.val != 0
}


fn strExpr(s: str): ^Expr {
    a := new(Atom)
    e := new(Expr)
    a^ = Atom{s, 0}
    e.atom = a
    return e
}


fn intExpr(i: int): ^Expr {
    a := new(Atom)
    e := new(Expr)
    a^ = Atom{"", i}
    e.atom = a
    return e
}


fn boolExpr(b: bool): ^Expr {
    a := new(Atom)
    e := new(Expr)
    if b {a^ = Atom{"T", int(true)}} else {a^ = Atom{"F", int(false)}}
    e.atom = a
    return e
}


// Elementary functions

fn car(x: ^Expr): ^Expr {
    if x.atom != null {
        error("car() is undefined for atoms")
    }
    return x.car
}


fn cdr(x: ^Expr): ^Expr {
    if x.atom != null {
        error("cdr() is undefined for atoms")
    }
    return x.cdr
}


fn cons(x, y: ^Expr): ^Expr {
    z := new(Expr)
    z.car = x
    z.cdr = y
    return z
}


fn atom(x: ^Expr): bool {
    return x.atom != null
}


fn eq(x, y: ^Expr): bool {
    if x.atom == null || y.atom == null {
        error("eq() is undefined for non-atoms")
    }
    return x.atom.name == y.atom.name
}


// Helper functions

fn eval(e, a: ^Expr): ^Expr


fn _null(x: ^Expr): bool {
    return x.atom.name == "nil" && x.car == null && x.cdr == null
}


fn equal(x, y: ^Expr): bool {
    if atom(x) {
        if atom(y) {
            return eq(x, y)
        } else {
            return false
        }
    } else if equal(car(x), car(y)) {
        return equal(cdr(x), cdr(y))
    } else {
        return false
    }
}


fn pairlis(x, y, a: ^Expr): ^Expr {
    if _null(x) {
        return a
    } else {
        return cons(cons(car(x), car(y)), pairlis(cdr(x), cdr(y), a))
    }
}


fn assoc(x, a: ^Expr): ^Expr {
    if equal(car(car(a)), x) {
        return car(a)
    } else {
        return assoc(x, cdr(a))
    }
}


fn evcon(c, a: ^Expr): ^Expr {
    if eval(car(car(c)), a).boolVal() {
        return eval(car(cdr(car(c))), a)
    } else {
        return evcon(cdr(c), a)
    }    
}


fn evlis(m, a: ^Expr): ^Expr {
    if _null(m) {
        return strExpr("nil")
    } else {
        return cons(eval(car(m), a), evlis(cdr(m), a))
    }
}


// Universal function (Lisp 1.5 manual, p. 13)

fn apply(f, x, a: ^Expr): ^Expr {  
    if atom(f) {
        if eq(f, strExpr("car")) {
            return car(car(x))
        } else if eq(f, strExpr("cdr")) {
            return cdr(car(x))
        } else if eq(f, strExpr("cons")) {
            return cons(car(x), car(cdr(x)))
        } else if eq(f, strExpr("atom")) {
            return boolExpr(atom(car(x)))
        } else if eq(f, strExpr("eq")) {
            return boolExpr(eq(car(x), car(cdr(x))))
        } else {
            return apply(eval(f, a), x, a)
        }
    } else if eq(car(f), strExpr("lambda")) {
        return eval(car(cdr(cdr(f))), pairlis(car(cdr(f)), x, a))     
    } else if eq(car(f), strExpr("label")) {
        return apply(car(cdr(cdr(f))), x, cons(cons(car(cdr(f)), car(cdr(cdr(f)))), a))
    } else {
        error("Illegal apply() call")
    }    
}


fn eval(e, a: ^Expr): ^Expr {
    if atom(e) {
        return cdr(assoc(e, a))
    } else if atom(car(e)) {
        if eq(car(e), strExpr("'")) {
            return car(cdr(e))
        } else if eq(car(e), strExpr("cond")) {
            return evcon(cdr(e), a)
        } else {
            return apply(car(e), evlis(cdr(e), a), a)
        }
    } else {
        return apply(car(e), evlis(cdr(e), a), a)
    }
}






